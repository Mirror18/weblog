# 全局异常处理+参数校验

通过前面的全局异常，我们明白所谓的全局异常处理器本质上就是一个处理异常的，替代的功能就是try+catch这一步的步骤。只需要原先能把异常给throw即可。

那么参数校验呢，我们从用的时候，就只是在User，也就是model中的字段上加上几个注解，表明可以给这字段赋值的范围。

然后那注解是代替的什么呢，代替的是原先没有注解的话，在对字段赋值的时候，检测字段赋值的产物。也就是加上了if判断，那么会像平常代码一样，如果赋值不正确就赋值null么，不可能，因为啥呢，因为我们不可能说在赋值之后，检测是否为默认值，这也忒蛋疼了。

那么能返回的是什么，那自然就是异常了。

这一切都绕回来了。

既然是异常，那我这全局异常处理器就可以发功了。



原先是什么呢，原先是加上了BindingResult。这是什么时候出现的，就是在我们添加参数检测的时候出现，再看使用的代码，发现就干了一件事，如果出现错误的话，就在这里进行捕捉返回。

那么我在入参里把这个给去了，是不是就可以发现出现的异常是什么。

对，这就是我们查到异常的方法。

![image-20241012030514431](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410120305551.png)

完美，那么就开始吧，去global中处理去。



处理完毕的结果

![image-20241012031210677](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410120312744.png)

其实这里还是有很多可以说到说到的，因为什么呢，如果按照我这代码去看的话，其实这里是有省略的，什么省略，那就是我在AOP中也有异常处理的，怎么到这里就没了。

往下看就明白了，先说结论，参数异常不在执行的时候进行捕获，而是在执行之后，AOP执行之后，再抛出的参数异常。AOP根本没有发生异常，也就是testController中没有发生异常。

全局异常捕捉到错误异常

![image-20241012032641273](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410120326342.png)



突然有个很有意思的事，属于写上来玩的。

![image-20241012032908037](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410120329112.png)

这里肯定是异常请求了，那么发生了什么事，咦，没有AOP的异常捕捉啊，

为什么，返回到AOP中，这玩意儿是先执行，如果执行过程中抛出异常，就会被AOP的异常所接收，对，因为这个异常内部处理了， 所以不见了。



那么现在所有的异常处理链可以说明下了。

运行异常 -> 被全局异常捕捉 -> 进行处理 -> 整体无异常

​						 -> 不能被处理的异常 -> 处理输出响应 -> 整体异常

参数异常 -> 内部捕获 -> 处理，无异常

 		-> 全局捕获 -> 处理，无异常

![image-20241012035247578](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410120352652.png)

其实看这个调用链的时候，发现全局异常处理应该是在AOP处理异常之后，