# 全局异常

怎么解释这一章节呢，

首先是自定义响应工具类，通过创建result的response类，然后在controller的调用中，我们将返回的数据进行包裹，格式上正确了，

那么同时有个疑问哈，我们输出过User的bean，也输出过ResponseEntiy的静态对象，那么有个疑问，那对于controller来说，我们其实只要能输出一个可序列化的玩意儿就行，

那么重点来了，在用postman的时候有没有发现一个细节，那就是在参数校验的时候，我们是用ResponseEntiy的badRequest方法返回请求参数不正确，也就是捕获到异常之后，我们返回一个错误的请求，请求代码为500来着吧，但是控制台没有任何的反应，其实也正常，因为我们每家log.warn。

但是之后有了包裹类的时候，我们却发现，请求返回的都是200，所以明白这种ResponseEntiy返回的是什么了么，那就是对响应字符进行修改。

那么返回响应类是什么呢，其实就是返回了一个可序列化的bean,所以响应代码都是200.不管是正常还是错误。同时也有响应错误所带来的信息，都可以包装上去。

那么问题来了，因为响应类中也有错误类型，那么我们在这整半天自定义异常算是什么。

其实牵扯到异常的事，因为我们也只能捕获runntimeExcption的异常，当我们感觉这里逻辑错误，我们需要主动抛出异常，那么可以抛出的异常就多种多样了，反正大不了throw exception.class 反正事没啥错，然后怎么处理呢，太乱七八糟了。毕竟每次相同情况下 抛出的错误都是可以随意的。

那么我在controller中捕获了这异常怎么办，那只有一种异常写一种处理方法。

太麻烦，于是就有了自定义异常，说白了，相同情况下，我遇到这异常了，我们都会抛出一个相同的异常，规定了抛出的异常类型，那么我们就可以统一对这玩意儿进行处理了。

那么怎么对异常进行处理呢，

对，没错，这就到了全局异常处理。也就是我们创建的globalExpectionHandle，

---

好，现在开始正式讲全局异常处理了，我们先回顾我们现在有的东西。

有一个响应类，可以返回正确，或者错误的信息，

我们自定义的异常类，用于在相同情况下，返回一个统一的异常类。



既然讲全局异常处理，那么就先抛开全局异常处理，如果我们没有这玩意的情况下会是什么样的，仅仅只是有上面的两个工具类。

切换到这个版本下，在testController中的这个请求，虽然我觉得挺傻逼，但是现在凑合着用也行。

![image-20241012003305947](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410120033250.png)

没错，就是进行try -catch。进行捕捉异常，那么是不是我每次要抛出异常的时候，都要这样去写。简直就是灾难，（当然，不认同这个写法的原因是我们有响应类还有自定义异常类，为什么还要写这么原始的抛出异常）





那我们迫切的需要解决的是什么，那就是我们都返回了统一的异常类，那我们是不是可以不用再controller或者service中再对抛出的异常进行处理呢，至少要把这个try-catch给扔掉。

于是全局异常类就这么水灵灵的出现了。

![image-20241012003901628](https://cdn.jsdelivr.net/gh/Mirror18/imgage@main//202410120039704.png)

当然代码细节我不会去写，因为都是写的很清楚的，

唯一特别强调的是@ControllerAdvice这个，虽然写的注释是全局异常类处理器，其实也没啥错，毕竟因为这个项目中只是用到了@ExceptionHandler这个注解，这俩配套是针对全局异常类，

但是这玩意儿可以搭配更多的东西，功能也不相同，唯一相同的作用，就是针对这个全局类下面的注解进行一个拓展，毕竟名字就是控制拓展嘛，

说句题外话，这玩意儿其实我看的挺早的，但是这么水灵灵的出现在我面前还是头一次，毕竟我对着文档是真特么的看不懂啊。



好了，废话结束。

那么有没有看出来什么，所谓的全局异常处理，重点就是再最后的处理上，没有明显的代码说我捕捉错误，但是在这里，会自动捕捉错误，然后进行处理。这里写的方法就是跟之前catch中捕获到了，进行处理的写的代码一样，顶多多了一个输出日志。



好了，全局异常结束，没错，就这样水灵灵的结束了。

至于响应类中的，其实说白了，对于传入的参数，我响应的时候，响应的好看一点，如果不介意其实可以返回字段的。用不着写这么多的方法。



